# Remove built-in rules and variables
# n.b. no-op for make --version < 4.0
MAKEFLAGS += -r
MAKEFLAGS += -R

TOOLCHAIN ?= arm-none-eabi

CARGO ?= cargo
# This will hopefully move into Cargo.toml (or Cargo.toml.local) eventually
RUSTFLAGS := "-C link-arg=-nostartfiles -C link-arg=-Tlayout.ld"

CC        := $(TOOLCHAIN)-gcc
SIZE      ?= $(TOOLCHAIN)-size
OBJCOPY   ?= $(TOOLCHAIN)-objcopy
OBJDUMP   ?= $(TOOLCHAIN)-objdump
OBJDUMP_FLAGS += --disassemble-all --source --disassembler-options=force-thumb -C --section-headers

# http://stackoverflow.com/questions/10858261/abort-makefile-if-variable-not-set
# Check that given variables are set and all have non-empty values,
# die with an error otherwise.
#
# Params:
#   1. Variable name(s) to test.
#   2. (optional) Error message to print.
check_defined = \
    $(strip $(foreach 1,$1, \
        $(call __check_defined,$1,$(strip $(value 2)))))
__check_defined = \
    $(if $(value $1),, \
      $(error Undefined $1$(if $2, ($2))))


$(call check_defined, PLATFORM)
$(call check_defined, TARGET)

# If environment variable V is non-empty, be verbose
ifneq ($(V),)
Q=
VERBOSE = --verbose
else
Q=@
VERBOSE =
endif

export TOCK_KERNEL_VERSION := $(shell git describe --always || echo notgit)

# Check that gcc version is new enough (> 5.1) - used during linking
CC_VERSION := $(shell $(CC) -dumpversion)
CC_VERSION_MAJOR := $(shell echo $(CC_VERSION) | cut -d '.' -f1)
ifeq (1,$(shell expr $(CC_VERSION_MAJOR) \>= 6))
  # no-op
else
  ifneq (5,$(CC_VERSION_MAJOR))
    $(info CC=$(CC) version $(CC_VERSION))
    $(error Your compiler is too old. Need gcc version > 5.1)
  endif
  CC_VERSION_MINOR := $(shell echo $(CC_VERSION) | cut -d '.' -f2)
  ifneq (1,$(shell expr $(CC_VERSION_MINOR) \> 1))
    $(info CC=$(CC) version $(CC_VERSION))
    $(error Your compiler is too old. Need gcc version > 5.1)
  endif
endif

ifneq ($(shell rustup component list | grep rust-src),rust-src (installed))
  $(shell rustup component add rust-src)
endif
ifneq ($(shell rustup target list | grep "$(TARGET) (installed)"),$(TARGET) (installed))
  $(shell rustup target add $(TARGET))
endif

# Dump configuration for verbose builds
ifneq ($(V),)
  $(info )
  $(info **************************************************)
  $(info TOCK KERNEL BUILD SYSTEM -- VERBOSE BUILD)
  $(info **************************************************)
  $(info Config:)
  $(info MAKEFLAGS=$(MAKEFLAGS))
  $(info OBJCOPY=$(OBJCOPY))
  $(info PLATFORM=$(PLATFORM))
  $(info TARGET=$(TARGET))
  $(info TOCK_KERNEL_VERSION=$(TOCK_KERNEL_VERSION))
  $(info TOOLCHAIN=$(TOOLCHAIN))
  $(info )
  $(info $(OBJCOPY) --version = $(shell $(OBJCOPY) --version))
  $(info rustc --version = $(shell rustc --version))
  $(info **************************************************)
  $(info )
endif

BUILDPATH := target/$(TARGET)/release/$(PLATFORM)
BUILDPATH_DEBUG := target/$(TARGET)/debug/$(PLATFORM)

.PHONY: all
all:	$(BUILDPATH).bin

.PHONY: lst
lst:	$(BUILDPATH).lst

.PHONY: debug
debug:	$(BUILDPATH_DEBUG).bin

.PHONY: doc
doc:
	RUSTDOCFLAGS=--document-private-items $(CARGO) doc $(VERBOSE) --release --target=$(TARGET)

$(BUILDPATH).lst: $(BUILDPATH).bin
	$(Q)$(OBJDUMP) $(OBJDUMP_FLAGS) $(BUILDPATH).elf > $(BUILDPATH).lst

.PHONY: $(BUILDPATH).bin
$(BUILDPATH).bin:
	$(Q)RUSTFLAGS=$(RUSTFLAGS) $(CARGO) build --target=$(TARGET) $(VERBOSE) --release
	$(Q)cp $(BUILDPATH) $(BUILDPATH).elf
	$(Q)$(SIZE) $(BUILDPATH).elf
	$(Q)$(OBJCOPY) -Obinary $(BUILDPATH).elf $@

.PHONY: $(BUILDPATH_DEBUG).bin
$(BUILDPATH_DEBUG).bin:
	$(Q)RUSTFLAGS=$(RUSTFLAGS) $(CARGO) build $(VERBOSE) --target=$(TARGET)
	$(Q)$(OBJDUMP) $(OBJDUMP_FLAGS) $(BUILDPATH_DEBUG).elf > $(BUILDPATH_DEBUG).lst
	$(Q)$(SIZE) $(BUILDPATH_DEBUG).elf
	$(Q)$(OBJCOPY) -Obinary $(BUILDPATH_DEBUG).elf $@

# `make check` runs the Rust compiler but does not actually output the final
# binary. This makes checking for Rust errors much faster.
.PHONY: check
check:
	$(Q)RUSTFLAGS=$(RUSTFLAGS) $(CARGO) check --target=$(TARGET) $(VERBOSE) --release

.PHONY: clean
clean::
	$(Q)$(CARGO) clean $(VERBOSE)
